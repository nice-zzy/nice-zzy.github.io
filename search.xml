<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AI大模型-1 baseline初体验</title>
    <url>/posts/6ea94fe8/</url>
    <content><![CDATA[<h1 id="大模型打卡第一天！——逻辑推理datawhale-AI夏令营"><a href="#大模型打卡第一天！——逻辑推理datawhale-AI夏令营" class="headerlink" title="大模型打卡第一天！——逻辑推理datawhale-AI夏令营"></a>大模型打卡第一天！——逻辑推理datawhale-AI夏令营</h1><p>1.体验一站式baseline</p>
<p>2.了解逻辑推理（以下为逻辑推理的笔记及一些理解补充，另附相关知识深入学习的网址参考）</p>
<p>[TOC]</p>
<h2 id="传统逻辑推理解决方式"><a href="#传统逻辑推理解决方式" class="headerlink" title="传统逻辑推理解决方式"></a>传统逻辑推理解决方式</h2><h4 id="知识表示：奠定推理基石"><a href="#知识表示：奠定推理基石" class="headerlink" title="知识表示：奠定推理基石"></a>知识表示：奠定推理基石</h4><p>逻辑推理始于将知识转化为计算机可以理解和操作的形式。这里有几个常用的逻辑系统：</p>
<ul>
<li>一阶逻辑：描述个体、属性及它们之间的关系，如“所有猫都有四条腿”。（可参考<a href="http://t.csdnimg.cn/5yzOe%EF%BC%89">http://t.csdnimg.cn/5yzOe）</a></li>
<li>命题逻辑：简单直观，适用于描述基本的真伪陈述，如“A是真”。（即逻辑推理判断真假<a href="http://t.csdnimg.cn/N7uJO%EF%BC%89">http://t.csdnimg.cn/N7uJO）</a></li>
<li>模态逻辑：引入了“可能”和“必然”的概念，帮助我们处理不确定性和可能性（<a href="http://t.csdnimg.cn/lihke%EF%BC%89">http://t.csdnimg.cn/lihke）</a></li>
<li>描述逻辑：专为构建知识图谱设计，有助于定义概念、类别和它们之间的联系，非常适合语义网（<a href="http://t.csdnimg.cn/FwuMe%EF%BC%89">http://t.csdnimg.cn/FwuMe）</a></li>
</ul>
<h4 id="推理引擎：推动逻辑向前发展"><a href="#推理引擎：推动逻辑向前发展" class="headerlink" title="推理引擎：推动逻辑向前发展"></a>推理引擎：推动逻辑向前发展</h4><p>推理引擎是执行逻辑推理的核心组件，它通过不同的方式分析知识并得出结论：</p>
<ul>
<li>前向链式推理：从已知事实出发，一步步应用规则，直至得出结论。</li>
<li>后向链式推理：从目标逆向寻找支持其成立的依据，类似侦探破案。</li>
<li>溯因推理：在直接证据不足时，通过最合理解释填补空白。</li>
<li><strong>非单调推理</strong>：随着新信息的加入，允许之前的结论被修正或推翻。(相比于单调推理，非单调推理并不依赖于严格的推理形式，符合现实合理性即可<a href="http://t.csdnimg.cn/oWrrv">http://t.csdnimg.cn/oWrrv</a>)</li>
</ul>
<h4 id="应对不确定性和不完整信息"><a href="#应对不确定性和不完整信息" class="headerlink" title="应对不确定性和不完整信息"></a>应对不确定性和不完整信息</h4><p>现实世界的数据往往不完整或模糊，为此，我们采用特殊策略应对：</p>
<ul>
<li>概率逻辑：结合概率理论，为不确定性提供数学基础。</li>
<li>模糊逻辑：允许不同程度的真值，超越了非黑即白的二元思维。</li>
<li><strong>缺省逻辑</strong>：在信息缺失时，基于合理假设做出最佳推测。</li>
</ul>
<h4 id="算法与优化：提升推理效率"><a href="#算法与优化：提升推理效率" class="headerlink" title="算法与优化：提升推理效率"></a>算法与优化：提升推理效率</h4><p>高效的推理需要优化算法，以下是一些常见的技术：</p>
<ul>
<li>单元传播：在处理布尔逻辑问题时，一旦确定某个变量的状态，立即更新所有相关条件。</li>
<li><strong>冲突驱动的子句学习（CDCL）</strong>：从冲突中提炼新规则，避免重复错误。(<a href="http://t.csdnimg.cn/Nej9P">http://t.csdnimg.cn/Nej9P</a>)</li>
<li>约束传播：通过缩小变量的取值范围，快速排除不可能选项，加速搜索过程</li>
</ul>
<h2 id="传统机器学习如何解决此类问题："><a href="#传统机器学习如何解决此类问题：" class="headerlink" title="传统机器学习如何解决此类问题："></a>传统机器学习如何解决此类问题：</h2><ol>
<li>特征工程: 首先，需要将问题和选项转换为机器可以理解和操作的特征向量。这可能包括将文本问题和答案选项编码为数值向量，比如通过词袋模型（Bag-of-Words）、TF-IDF 或者词嵌入（Word Embeddings）如 Word2Vec 或 GloVe。</li>
<li>模型选择: 接下来，选择一个适合分类任务的模型。对于选择题，常见的模型有：<ol>
<li>决策树</li>
<li>支持向量机</li>
<li>随机森林</li>
<li>逻辑回归</li>
<li>神经网络</li>
</ol>
</li>
<li>训练模型: 使用已知正确答案的题目作为训练数据，将问题和选项的特征向量输入模型，并标记正确的答案。模型会学习到从特征到正确答案之间的映射关系。</li>
<li>预测与评估: 当模型训练完成后，可以使用测试集来评估模型的准确性和泛化能力。测试集应该包含模型未曾见过的问题和选项。</li>
<li>解决新问题: 对于新的选择题，模型会接收问题和选项的特征向量作为输入，并输出每个选项的概率或分数，最高分的选项即为模型认为的正确答案。</li>
</ol>
<p>为了提高模型在逻辑推理任务上的性能，可以尝试以下策略：</p>
<ul>
<li>逻辑规则嵌入：在模型中添加逻辑规则，例如，如果模型是神经网络，可以考虑使用神经符号集成（Neuro-Symbolic Integration）技术，其中逻辑规则被编码为网络的一部分。</li>
<li>增强学习：使用增强学习来奖励模型在逻辑上合理的选择，这样模型不仅学习到数据中的模式，还能学会基于逻辑原则做出选择。</li>
<li>元学习：让模型学习如何学习，通过在多个相关任务上训练，使模型能够更快地适应新类型的选择题。</li>
</ul>
<h2 id="深度学习如何解决此类问题："><a href="#深度学习如何解决此类问题：" class="headerlink" title="深度学习如何解决此类问题："></a>深度学习如何解决此类问题：</h2><p>深度学习方法在处理逻辑推理类型的选择题时，主要依赖于其强大的模式识别和抽象能力，以及对复杂数据结构的处理能力。以下是深度学习解决这类问题的一般步骤和方法：</p>
<ol>
<li><strong>数据预处理</strong>: 将文本数据转换为可以输入到神经网络的格式，常见的做法是使用词嵌入（如Word2Vec、GloVe或FastText）或字符级嵌入，将文本转化为数值向量。（将NLP应用于机器学习，具体关于词嵌入方法可参考<a href="http://t.csdnimg.cn/FG7tz%EF%BC%89">http://t.csdnimg.cn/FG7tz）</a></li>
<li><strong>模型架构选择</strong>: 根据问题的复杂度和数据的特性选择合适的模型。常用的深度学习模型包括：<ol>
<li>循环神经网络（RNNs）: 特别是长短期记忆网络（LSTMs）和门控循环单元（GRUs），它们擅长处理序列数据，能够捕捉到文本中的上下文关系。（与传统前馈神经网络不同的是它可以记忆之前的信息，方便做出推理及预测<a href="http://t.csdnimg.cn/8ngKz%EF%BC%89">http://t.csdnimg.cn/8ngKz）</a></li>
<li>卷积神经网络（CNNs）: 卷积层能够检测局部模式，对于短文本和固定长度的输入有效。（可分析局部元素，相当于一个滤波器，不同的卷积矩阵可帮助实现不同的目的<a href="http://t.csdnimg.cn/BwXLr%EF%BC%89">http://t.csdnimg.cn/BwXLr）</a></li>
<li>变换器（Transformers）: 如BERT、RoBERTa等预训练模型，它们利用自注意力机制处理序列数据，能够高效地处理长文本和理解上下文。</li>
<li>记忆增强网络: 如记忆网络（Memory Networks）和端到端记忆网络（End-to-End Memory Networks），它们可以在内部存储和检索信息，有助于逻辑推理。（<a href="http://t.csdnimg.cn/sKBMa%EF%BC%89">http://t.csdnimg.cn/sKBMa）</a></li>
</ol>
</li>
<li><strong>多选题处理</strong>: 将选择题设计为多标签分类问题，其中每个选项都是一个潜在的标签。模型需要预测每个选项的得分或概率，最终选择得分最高的选项作为答案。</li>
<li><strong>训练</strong>: 利用标注过的数据集进行训练，目标是最小化损失函数，通常是交叉熵损失，以提高模型在预测正确答案时的准确性。</li>
<li><strong>推理阶段</strong>: 在测试或应用阶段，模型接收新的问题和选项，将其转换为相应的向量表示，然后通过模型进行预测，得到每个选项的得分或概率分布，最后选择得分最高的选项作为答案。</li>
<li><strong>后处理和解释</strong>: 可能需要额外的步骤来解释模型的决策，例如通过注意力权重来了解模型在做决策时关注了哪些部分的文本。</li>
<li><strong>集成学习</strong>: 结合多个模型的预测结果，通过投票或加权平均的方式提高最终预测的准确率。</li>
<li><strong>持续学习和调整</strong>: 如果可用，可以使用增量学习或在线学习方法，使模型能够随着更多数据的到来而不断改进。</li>
</ol>
<p>深度学习模型的一个关键优势在于它们能够自动学习特征表示，不需要人工进行特征工程，这对于逻辑推理问题尤为重要，因为这些问题可能涉及到复杂的语言模式和隐含的逻辑关系。此外，预训练模型（如BERT）的出现使得模型能够在大量未标记文本上进行预训练，然后再针对具体任务进行微调，这种迁移学习的能力极大地提高了模型的性能和泛化能力。</p>
]]></content>
      <categories>
        <category>AI大模型</category>
      </categories>
      <tags>
        <tag>逻辑推理</tag>
        <tag>baseline</tag>
      </tags>
  </entry>
  <entry>
    <title>AI大模型-2Baseline精读</title>
    <url>/posts/5dacfb0c/</url>
    <content><![CDATA[<h1 id="AI大模型打卡2！——Datawhale夏令营"><a href="#AI大模型打卡2！——Datawhale夏令营" class="headerlink" title="AI大模型打卡2！——Datawhale夏令营"></a>AI大模型打卡2！——Datawhale夏令营</h1><p>引言：打卡2分为两部分，第一部分为LLM的一些理论知识，二是代码的解析。打卡2主要是对打卡1的进一步理解，重点在对baseline代码的精读分析上，笔者在原代码基础上补充了很多基础知识、语法，适合新手食用。</p>
<h2 id="一、进一步理解LLM"><a href="#一、进一步理解LLM" class="headerlink" title="一、进一步理解LLM"></a>一、进一步理解LLM</h2><p>LLM，即Large Language Model（大型语言模型），是人工智能领域，特别是自然语言处理（NLP）中的一个重要概念。LLM是指那些具有大量参数、能够处理复杂语言任务的深度学习模型，这些模型通常基于transformer结构。</p>
<h3 id="1-Transformer结构"><a href="#1-Transformer结构" class="headerlink" title="1.Transformer结构"></a>1.Transformer结构</h3><p>Transformer模型采用编码器-解码器（Encoder-Decoder）结构。其中，编码器负责将输入序列映射为连续表示，解码器则根据编码器的输出逐步生成输出序列。</p>
<h4 id="1-1编码器（Encoder）"><a href="#1-1编码器（Encoder）" class="headerlink" title="1.1编码器（Encoder）"></a>1.1编码器（Encoder）</h4><p>编码器由多个编码器层堆叠而成，每个编码器层包含两个主要子层：</p>
<ol>
<li><strong>多头自注意力机制（Multi-Head Attention）</strong>：这是Transformer模型的核心组件之一。它允许模型同时关注输入序列中不同位置的信息，从而捕捉序列中的全局依赖关系。多头自注意力机制通过多个“头”（heads）并行计算自注意力，然后将结果拼接起来，以增强模型的表达能力。</li>
<li><strong>前馈神经网络（Feed Forward Neural Network）</strong>：这是一个简单的全连接前馈网络，用于对自注意力机制的输出进行进一步处理。它通常包括两个线性变换和一个ReLU激活函数。</li>
</ol>
<p>​		此外，每个子层之间还包含了残差连接（Residual Connection）和层归一化（Layer Normalization），以帮助模型在训练过程中保持稳定性。</p>
<h4 id="1-2解码器（Decoder）"><a href="#1-2解码器（Decoder）" class="headerlink" title="1.2解码器（Decoder）"></a>1.2解码器（Decoder）</h4><p>解码器同样由多个解码器层堆叠而成，但每个解码器层包含三个主要子层：</p>
<ol>
<li><strong>第一个多头自注意力机制</strong>：与编码器中的自注意力机制类似，但它采用了掩码（Masking）操作来防止在预测当前位置时看到未来的信息。</li>
<li><strong>编码器-解码器注意力机制（Encoder-Decoder Attention）</strong>：这个子层允许解码器关注编码器的输出，从而捕捉输入序列和输出序列之间的依赖关系。</li>
<li><strong>前馈神经网络</strong>：与编码器中的前馈神经网络相同，用于对注意力机制的输出进行进一步处理。</li>
</ol>
<h4 id="1-3输入与输出"><a href="#1-3输入与输出" class="headerlink" title="1.3输入与输出"></a>1.3输入与输出</h4><ol>
<li><strong>输入</strong>：Transformer的输入包括单词嵌入（Word Embedding）和位置嵌入（Positional Encoding）。单词嵌入用于将输入的单词转换为固定维度的向量表示；位置嵌入用于提供单词在序列中的位置信息，因为Transformer模型本身不依赖于序列的顺序信息。</li>
<li><strong>输出</strong>：Transformer的输出取决于具体的任务。在机器翻译等序列到序列的任务中，解码器的输出会经过一个线性层和softmax层，以生成目标序列中每个位置的概率分布。</li>
</ol>
<h4 id="1-4自注意力机制（Self-Attention-Mechanism）"><a href="#1-4自注意力机制（Self-Attention-Mechanism）" class="headerlink" title="1.4自注意力机制（Self-Attention Mechanism）"></a>1.4自注意力机制（Self-Attention Mechanism）</h4><p>​		自注意力机制是Transformer模型中的关键组件。它通过计算输入序列中所有位置之间的相似度得分，来捕捉序列中的依赖关系。具体来说，自注意力机制接受三个输入：查询（Query）、键（Key）和值（Value），它们都是输入序列的线性变换结果。然后，通过计算查询与键之间的相似度得分，并将这些得分应用于值上，得到加权和作为输出。这种机制允许模型同时考虑输入序列中所有位置的信息，从而更好地捕捉全局依赖关系。</p>
<h3 id="2-LLM与传统机器学习的区别"><a href="#2-LLM与传统机器学习的区别" class="headerlink" title="2.LLM与传统机器学习的区别"></a>2.LLM与传统机器学习的区别</h3><p>​		简而言之，LLM以其强大的生成能力、上下文理解能力和迁移学习能力在自然语言处理领域展现出巨大的潜力；而传统机器学习则以其简单高效、易于解释的特点在多个领域和场景中发挥着重要作用。</p>
<h4 id="2-1定义与基本原理"><a href="#2-1定义与基本原理" class="headerlink" title="2.1定义与基本原理"></a>2.1定义与基本原理</h4><ul>
<li><strong>LLM</strong>：LLM基于深度学习技术，特别是Transformer结构的大型语言模型。它通过在海量的文本数据上进行无监督学习和迁移学习，学会了理解和生成自然语言文本的能力。LLM具有强大的上下文理解能力、生成能力和迁移学习能力。</li>
<li><strong>传统机器学习</strong>：传统机器学习是指通过算法对数据进行学习和分析，从而找到数据中的模式和规律，并利用这些模式和规律对未知数据进行预测或分类的技术。传统机器学习算法多种多样，包括但不限于决策树、支持向量机、随机森林等。</li>
</ul>
<h4 id="2-2数据需求与训练过程"><a href="#2-2数据需求与训练过程" class="headerlink" title="2.2数据需求与训练过程"></a>2.2数据需求与训练过程</h4><ul>
<li><strong>LLM</strong>：LLM需要大量的文本数据进行训练，这些数据通常来自互联网上的各种文本资源。训练过程中，LLM会学习文本中的语言模式和规律，并通过无监督学习不断优化其参数。此外，LLM还具有迁移学习能力，可以在不同任务之间进行快速适应和微调。</li>
<li><strong>传统机器学习</strong>：传统机器学习对数据的需求相对较少，可以根据具体任务的需求选择适当的数据集进行训练。训练过程中，传统机器学习算法会根据数据集中的特征进行学习和优化，以建立预测或分类模型。</li>
</ul>
<h4 id="2-3应用场景与性能"><a href="#2-3应用场景与性能" class="headerlink" title="2.3应用场景与性能"></a>2.3应用场景与性能</h4><ul>
<li><strong>LLM</strong>：多任务、复杂场景处理能力强。在自然语言处理领域具有广泛的应用场景，如文本生成、信息提取、文本分类、情感分析、机器翻译等。由于其强大的生成能力和上下文理解能力，LLM在创意写作、自动摘要、对话系统等方面表现出色。此外，LLM还可以通过迁移学习快速适应不同的NLP任务，并在性能上取得显著提升。</li>
<li><strong>传统机器学习</strong>：传统机器学习在处理复杂多变的自然语言任务时，可能表现出一定的局限性。而在信用评估、客户分类、在线广告推荐等领域中的性能稳定可靠，能够快速得到结果。</li>
</ul>
<h4 id="2-4计算资源与可解释性"><a href="#2-4计算资源与可解释性" class="headerlink" title="2.4计算资源与可解释性"></a>2.4计算资源与可解释性</h4><ul>
<li><strong>LLM</strong>：由于LLM模型规模庞大且参数众多，因此需要大量的计算资源进行训练和推理。此外，LLM的决策过程往往是黑箱操作，难以解释其背后的原因和逻辑。这在一定程度上限制了LLM在某些需要高可解释性场景中的应用。</li>
<li><strong>传统机器学习</strong>：传统机器学习算法的计算资源需求相对较低，可以在较短时间内完成训练和推理过程。此外，部分传统机器学习算法具有较好的可解释性，能够解释模型的决策过程和结果。这使得传统机器学习在某些需要高可解释性场景中具有优势。</li>
</ul>
<h2 id="二、baseline代码精读"><a href="#二、baseline代码精读" class="headerlink" title="二、baseline代码精读"></a>二、baseline代码精读</h2><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h3><h4 id="配置环境、配置API"><a href="#配置环境、配置API" class="headerlink" title="配置环境、配置API"></a><strong>配置环境、配置API</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install scipy openai tiktoken retry dashscope loguru</span><br><span class="line">dashscope.api_key=&quot;sk-&quot;</span><br></pre></td></tr></table></figure>

<h4 id="导入所需环境，引入所需的库-已注释，后续会对相关知识有所补充"><a href="#导入所需环境，引入所需的库-已注释，后续会对相关知识有所补充" class="headerlink" title="导入所需环境，引入所需的库(已注释，后续会对相关知识有所补充)"></a><strong>导入所需环境，引入所需的库(已注释，后续会对相关知识有所补充)</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json 				#编码和解码JSON数据</span><br><span class="line">import os					#执行文件、目录、环境变量的相关操作</span><br><span class="line">from pprint import pprint	#美化输出数据结构的模块</span><br><span class="line">import re					#正则表达式</span><br><span class="line">from tqdm import tqdm		#添加一个进度提示信息</span><br><span class="line">import random				#随机</span><br><span class="line"></span><br><span class="line">import uuid					#生成唯一通识符</span><br><span class="line">import openai				#用于与OpenAI的API进行交互</span><br><span class="line">import tiktoken</span><br><span class="line">import numpy as np			#Python的一个库，用于支持大量的维度数组与矩阵运算</span><br><span class="line">import requests				#发送HTTP请求</span><br><span class="line">from retry import retry		#用于自动重试失败的函数调用</span><br><span class="line">from scipy import sparse	#scipy库中的稀疏矩阵模块，用于处理大型稀疏矩阵</span><br><span class="line">#from rank_bm25 import BM25Okapi</span><br><span class="line">#import jieba</span><br><span class="line">from http import HTTPStatus	#用于在HTTP响应中指示服务器的响应状态，如请求成功、请求错误、重定向等</span><br><span class="line">import dashscope			#引用阿里云模型服务产品</span><br><span class="line"></span><br><span class="line">from concurrent.futures import ThreadPoolExecutor, as_completed	#允许多线程任务处理</span><br><span class="line">from loguru import logger	#日志记录</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">logger.remove()  			#移除默认的控制台输出</span><br><span class="line">logger.add(&quot;logs/app_&#123;time:YYYY-MM-DD&#125;.log&quot;, level=&quot;INFO&quot;, rotation=&quot;00:00&quot;, retention=&quot;10 days&quot;, compression=&quot;zip&quot;)</span><br><span class="line">&quot;&quot;&quot;logs/app_&#123;time:YYYY-MM-DD&#125;.log&quot;: 指定日志文件的路径和名称,会根据当天的日期来命名</span><br><span class="line">level=&quot;INFO&quot;: 只有INFO级别及以上的日志（如WARNING、ERROR等）会被记录到文件中</span><br><span class="line">rotation=&quot;00:00&quot;: 每天会创建一个新的日志文件来记录当天的日志信息。</span><br><span class="line">retention=&quot;10 days&quot;: 日志文件的保留时间为10天</span><br><span class="line">compression=&quot;zip&quot;: 日志文件的压缩方式为zip&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">MODEL_NAME = &#x27;qwen2-7b-instruct&#x27;	#模型名称</span><br></pre></td></tr></table></figure>



<h3 id="2-答案生成"><a href="#2-答案生成" class="headerlink" title="2.答案生成"></a>2.答案生成</h3><h4 id="2-1大模型部分"><a href="#2-1大模型部分" class="headerlink" title="2.1大模型部分"></a>2.1大模型部分</h4><h5 id="定义函数call-qwen-api，用于调用模型"><a href="#定义函数call-qwen-api，用于调用模型" class="headerlink" title="定义函数call_qwen_api，用于调用模型"></a><strong>定义函数call_qwen_api，用于调用模型</strong></h5><p>以下涉及到的python基础语法知识：列表、字典、条件语句（均注释，基础，详细可自行查阅python手册）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def call_qwen_api(MODEL_NAME, query):</span><br><span class="line">    # 调用dashscope模型推理，通过http传输的json封装返回结果</span><br><span class="line">    # 创建名为messages的列表，其中包含一个字典。这个字典表示了要发送给模型的请求消息，&#x27;role&#x27;键设置为&#x27;user&#x27;，表示消息的发送者角色，&#x27;content&#x27;键设置为query参数的值，即用户输入的查询文本 </span><br><span class="line">    messages = [</span><br><span class="line">        &#123;&#x27;role&#x27;: &#x27;user&#x27;, &#x27;content&#x27;: query&#125;]</span><br><span class="line">    response = dashscope.Generation.call(</span><br><span class="line">        MODEL_NAME,</span><br><span class="line">        messages=messages,</span><br><span class="line">        result_format=&#x27;message&#x27;,  # set the result is message format.</span><br><span class="line">    )</span><br><span class="line">    #如果请求成功，打印输出结果</span><br><span class="line">    if response.status_code == HTTPStatus.OK:</span><br><span class="line">        print(response)</span><br><span class="line">        return response[&#x27;output&#x27;][&#x27;choices&#x27;][0][&#x27;message&#x27;][&#x27;content&#x27;]</span><br><span class="line">    #如果请求失败，打印请求ID、状态码、错误码和错误消息，并抛出Exception异常</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;Request id: %s, Status code: %s, error code: %s, error message: %s&#x27; % (</span><br><span class="line">            response.request_id, response.status_code,</span><br><span class="line">            response.code, response.message</span><br><span class="line">        ))</span><br><span class="line">        raise Exception()</span><br></pre></td></tr></table></figure>



<h5 id="定义函数api-retry用于对-API-调用进行重试，直到达到最大尝试次数或成功执行为止"><a href="#定义函数api-retry用于对-API-调用进行重试，直到达到最大尝试次数或成功执行为止" class="headerlink" title="定义函数api_retry用于对 API 调用进行重试，直到达到最大尝试次数或成功执行为止"></a><strong>定义函数api_retry用于对 API 调用进行重试，直到达到最大尝试次数或成功执行为止</strong></h5><p>如果出现错误我们存储到日志文件</p>
<p>以下涉及到的python语法知识：异常处理、循环控制、日志记录以及时间控制（均注释）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def api_retry(MODEL_NAME, query):</span><br><span class="line">    # 最大尝试次数5次</span><br><span class="line">    max_retries = 5</span><br><span class="line">    # 再次尝试等待时间60s</span><br><span class="line">    retry_delay = 60  # in seconds</span><br><span class="line">    attempts = 0</span><br><span class="line">    while attempts &lt; max_retries:			#循环，try-exception结构</span><br><span class="line">        try:								#调用模型API尝试</span><br><span class="line">            return call_qwen_api(MODEL_NAME, query)</span><br><span class="line">        except Exception as e:				</span><br><span class="line">            attempts += 1   				#捕获异常，则继续尝试</span><br><span class="line">            if attempts &lt; max_retries:</span><br><span class="line">                logger.warning(f&quot;Attempt &#123;attempts&#125; failed for text: &#123;query&#125;. Retrying in &#123;retry_delay&#125; seconds...&quot;)			   </span><br><span class="line">#未超过最大次数出现错误时WARNING级别及以上的日志（如ERROR和CRITICAL）会被记录。format参数定义了日志消息的格式，包括时间戳、日志级别和消息本身</span><br><span class="line">                time.sleep(retry_delay)		</span><br><span class="line">#暂停，这个函数通常用于在重试机制中，当某个操作失败时，等待一段时间后再重试，以避免因为短时间内连续请求而导致资源耗尽或服务器压力过大</span><br><span class="line">            else:</span><br><span class="line">                logger.error(f&quot;All &#123;max_retries&#125; attempts failed for text: &#123;query&#125;. Error: &#123;e&#125;&quot;)</span><br><span class="line">                raise						#抛出异常</span><br></pre></td></tr></table></figure>

<p>eg:如果所有次数用尽，请求失败结果示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2023-04-01 12:00:00 - WARNING - Attempt 1 failed for text: some query text. Retrying in 60 seconds...  </span><br><span class="line"># ...（等待60秒）...  </span><br><span class="line">2023-04-01 12:01:00 - WARNING - Attempt 2 failed for text: some query text. Retrying in 60 seconds...  </span><br><span class="line"># ...（继续重试直到达到最大次数）...  </span><br><span class="line">2023-04-01 12:04:00 - ERROR - All 5 attempts failed for text: some query text. Error: Request id: ..., Status code: 400, error code: ..., error message: ...  </span><br><span class="line">Failed to get result: Request id: ..., Status code: 400, error code: ..., error message: ...</span><br></pre></td></tr></table></figure>

<p>上述结果示例中的 <code>...</code> 为请求ID、状态码、错误码和错误消息</p>
<h5 id="定义prompt的模版函数get-prompt，通过字符串处理的方式拼接完整的prompt"><a href="#定义prompt的模版函数get-prompt，通过字符串处理的方式拼接完整的prompt" class="headerlink" title="定义prompt的模版函数get_prompt，通过字符串处理的方式拼接完整的prompt"></a><strong>定义prompt的模版函数get_prompt，通过字符串处理的方式拼接完整的prompt</strong></h5><p>以下为该代码中定义的prompt模板，所涉及的python语法知识：列表推导式、enumerate函数（已注释）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def get_prompt(problem, question, options):</span><br><span class="line"></span><br><span class="line">    options = &#x27;\n&#x27;.join(f&quot;&#123;&#x27;ABCDEFG&#x27;[i]&#125;. &#123;o&#125;&quot; for i, o in enumerate(options))</span><br><span class="line">&#x27;&#x27;&#x27;这里使用列表推导式&#x27;\n&#x27;.join(f&quot;&#123;&#x27;ABCDEFG&#x27;[i]&#125;. &#123;o&#125;&quot; for i, o in enumerate(options))来生成选项字符串，其中每个选项前都加上了字母前缀（从A到G），并且选项之间用换行符\n分隔，使生成最多7个选项分别为A-G，且各占一行</span><br><span class="line">enumerate函数：用于将一个可遍历的数据对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和数据下标，通常用在for循环当中。在这个例子中，它被用来遍历options列表，同时获取每个选项的索引（i）和值（o）&#x27;&#x27;&#x27;</span><br><span class="line">    prompt = f&quot;&quot;&quot;你是一个逻辑推理专家，擅长解决逻辑推理问题。以下是一个逻辑推理的题目，形式为单项选择题。所有的问题都是（close-world assumption）闭世界假设，即未观测事实都为假。请逐步分析问题并在最后一行输出答案，最后一行的格式为&quot;答案是：A&quot;。题目如下：</span><br><span class="line">#以上prompt字符串构建了提示或说明文本用于告知大模型</span><br><span class="line"></span><br><span class="line">### 题目:</span><br><span class="line">&#123;problem&#125;</span><br><span class="line"></span><br><span class="line">### 问题:</span><br><span class="line">&#123;question&#125;</span><br><span class="line">&#123;options&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">    # print(prompt)</span><br><span class="line">    return prompt</span><br></pre></td></tr></table></figure>

<h5 id="涉及到的知识补充：Prompt提示工程（Prompt-Engineering）"><a href="#涉及到的知识补充：Prompt提示工程（Prompt-Engineering）" class="headerlink" title="涉及到的知识补充：Prompt提示工程（Prompt Engineering）"></a>涉及到的知识补充：Prompt提示工程（Prompt Engineering）</h5><p>也称为上下文提示或指令工程，是一种重要的技术和方法，主要用于指导预训练的大规模语言模型（LLMs）生成高质量、准确且有针对性的输出</p>
<p>一个有效的Prompt通常包含以下几个关键要素：</p>
<ol>
<li><p><strong>引导语或指示语</strong>：明确告诉模型需要完成什么样的任务。</p>
</li>
<li><p><strong>上下文信息</strong>：提供必要的背景知识，帮助模型更好地理解问题。</p>
</li>
<li><p><strong>任务描述</strong>：明确地描述您期望模型执行的具体任务。</p>
</li>
<li><p><strong>输出格式指示</strong>：如果需要特定格式的输出，需要在Prompt中指明。</p>
</li>
<li><p><strong>角色设定</strong>：为模型定义一个角色，以缩小问题范围并减少歧义。</p>
</li>
</ol>
<h4 id="2-2抽取函数"><a href="#2-2抽取函数" class="headerlink" title="2.2抽取函数"></a>2.2抽取函数</h4><h5 id="定义extract抽取函数将大语言模型生成的结果抽取成答案对应的选项"><a href="#定义extract抽取函数将大语言模型生成的结果抽取成答案对应的选项" class="headerlink" title="定义extract抽取函数将大语言模型生成的结果抽取成答案对应的选项"></a>定义extract抽取函数将大语言模型生成的结果抽取成答案对应的选项</h5><p>这里的匹配原则和prompt呼应。我们可以看到prompt要求【最后一行的格式为”答案是：A”】这样的规范，那么我们采用正则表达式re.compile方法匹配到答案对应的选项。当我们匹配为空时，我们默认选”A”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def extract(input_text):</span><br><span class="line">    ans_pattern = re.compile(r&quot;答案是：(.)&quot;, re.S)</span><br><span class="line"></span><br><span class="line">    problems = ans_pattern.findall(input_text)</span><br><span class="line">    # print(problems)</span><br><span class="line">    if(problems == &#x27;&#x27;):</span><br><span class="line">        return &#x27;A&#x27;</span><br><span class="line">    return problems[0]</span><br></pre></td></tr></table></figure>

<h5 id="涉及到的知识补充：正则表达式"><a href="#涉及到的知识补充：正则表达式" class="headerlink" title="涉及到的知识补充：正则表达式"></a>涉及到的知识补充：正则表达式</h5><p>正则表达式模式（Regular Expression Pattern）是一种特殊的字符串模式，用于描述在搜索文本时要匹配的一个或多个字符串。它们被设计为“通用的字符串搜索算法”，可以通过一种特殊的语法来定义搜索的模式。这些模式被广泛应用于文本处理、数据验证、搜索和替换等任务中。</p>
<p>正则表达式模式由一系列字符和特殊字符（称为“元字符”）组成，这些特殊字符在正则表达式中具有特殊的含义，而不是它们字面意义上的字符。例如，<code>.</code>（点）在正则表达式中通常表示匹配除换行符之外的任何单个字符，而<code>*</code>（星号）表示匹配前面的子表达式零次或多次。</p>
<p>下面是一些常见的正则表达式元字符和它们的含义：</p>
<ul>
<li><code>.</code>：匹配除换行符 <code>\n</code> 之外的任何单个字符。</li>
<li><code>^</code>：匹配输入字符串的开始位置。</li>
<li><code>$</code>：匹配输入字符串的结束位置。</li>
<li><code>*</code>：匹配前面的子表达式零次或多次。</li>
<li><code>+</code>：匹配前面的子表达式一次或多次。</li>
<li><code>?</code>：匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</li>
<li><code>&#123;n&#125;</code>：n 是一个非负整数。匹配确定的 n 次。</li>
<li><code>&#123;n,&#125;</code>：n 是一个非负整数。至少匹配 n 次。</li>
<li><code>&#123;n,m&#125;</code>：m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。</li>
<li><code>[xyz]</code>：字符集合。匹配所包含的任意一个字符。</li>
<li><code>[^xyz]</code>：负值字符集合。匹配未包含的任意字符。</li>
<li><code>\s</code>：匹配任何空白字符，包括空格、制表符、换页符等等。</li>
<li><code>\S</code>：匹配任何非空白字符。</li>
<li><code>\d</code>：匹配一个数字字符。等价于 <code>[0-9]</code>。</li>
<li><code>\D</code>：匹配一个非数字字符。等价于 <code>[^0-9]</code>。</li>
<li><code>\w</code>：匹配包括下划线的任何单词字符。等价于 <code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code>：匹配任何非单词字符。等价于 <code>[^A-Za-z0-9_]</code>。</li>
</ul>
<p>在编程中，正则表达式通常通过特定的库或函数来实现，Python 中的 <code>re</code> 模块就是这样一个例子。通过使用 <code>re</code> 模块提供的函数，如 <code>search()</code>、<code>match()</code>、<code>findall()</code> 和 <code>sub()</code> 等，可以方便地在 Python 程序中应用正则表达式来执行文本搜索、替换和验证等操作</p>
<p>以下是对Python中<code>re</code>模块中的<code>search()</code>、<code>match()</code>、<code>findall()</code>和<code>sub()</code>函数的详细解释：</p>
<p><strong>1. <code>search(pattern, string, flags=0)</code></strong></p>
<p><strong>用途</strong>：<br><code>search()</code>函数用于在字符串中搜索与正则表达式模式匹配的第一个位置。它会在整个字符串中查找匹配项，而不仅仅是字符串的开头。</p>
<p><strong>参数</strong>：</p>
<ul>
<li><code>pattern</code>：要匹配的正则表达式模式。</li>
<li><code>string</code>：要搜索的字符串。</li>
<li><code>flags</code>：可选参数，用于控制正则表达式的匹配方式，如是否忽略大小写、是否多行匹配等。默认为0，表示没有特殊标志。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>如果找到匹配项，返回一个匹配对象（Match object），该对象包含有关匹配的信息，如匹配的位置、匹配的文本等。</li>
<li>如果没有找到匹配项，返回<code>None</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line">  </span><br><span class="line">pattern = <span class="string">&#x27;world&#x27;</span>  </span><br><span class="line">string = <span class="string">&#x27;Hello, world! This is a test.&#x27;</span>  </span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Found:&quot;</span>, <span class="keyword">match</span>.group())  <span class="comment"># 输出: Found: world  </span></span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not found&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>2. <code>match(pattern, string, flags=0)</code></strong></p>
<p><strong>用途</strong>：<br><code>match()</code>函数尝试从字符串的起始位置开始匹配一个正则表达式，如果不是起始位置匹配成功的话，<code>match()</code>就返回<code>None</code>。</p>
<p><strong>参数</strong>：<br>与<code>search()</code>相同。</p>
<p><strong>返回值</strong>：</p>
<ul>
<li>如果字符串的起始位置与正则表达式匹配，返回一个匹配对象。</li>
<li>否则返回<code>None</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line">  </span><br><span class="line">pattern = <span class="string">&#x27;Hello&#x27;</span>  </span><br><span class="line">string = <span class="string">&#x27;Hello, world! This is a test.&#x27;</span>  </span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(pattern, string)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Found:&quot;</span>, <span class="keyword">match</span>.group())  <span class="comment"># 输出: Found: Hello  </span></span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not found&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3. <code>findall(pattern, string, flags=0)</code></strong></p>
<p><strong>用途</strong>：<br><code>findall()</code>函数在字符串中查找所有与正则表达式匹配的非重叠匹配项，并返回一个列表。</p>
<p><strong>参数</strong>：<br>与<code>search()</code>相同。</p>
<p><strong>返回值</strong>：</p>
<ul>
<li>返回一个列表，包含所有匹配项。如果正则表达式包含分组，则返回的是一个元组的列表，每个元组包含一个分组内的匹配项。</li>
<li>如果没有找到任何匹配项，返回一个空列表。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line">  </span><br><span class="line">pattern = <span class="string">r&#x27;\b\w+\b&#x27;</span>  </span><br><span class="line">string = <span class="string">&#x27;Hello, world! This is a test.&#x27;</span>  </span><br><span class="line">words = re.findall(pattern, string)  </span><br><span class="line"><span class="built_in">print</span>(words)  <span class="comment"># 输出: [&#x27;Hello&#x27;, &#x27;world&#x27;, &#x27;This&#x27;, &#x27;is&#x27;, &#x27;a&#x27;, &#x27;test&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>4. <code>sub(pattern, repl, string, count=0, flags=0)</code></strong></p>
<p><strong>用途</strong>：<br><code>sub()</code>函数用于执行正则表达式的替换操作，可以在字符串中搜索匹配某个正则表达式模式的部分，并将其替换为指定的内容。</p>
<p><strong>参数</strong>：</p>
<ul>
<li><code>pattern</code>：要匹配的正则表达式模式。</li>
<li><code>repl</code>：用于替换匹配到的部分的字符串或函数。如果是一个字符串，则其中的反斜杠转义字符将被处理；如果是一个函数，则该函数将被调用，并且它的返回值将用作替换字符串。</li>
<li><code>string</code>：要进行替换操作的原始字符串。</li>
<li><code>count</code>：可选参数，指定最多替换次数，默认为0，表示替换所有匹配到的部分。</li>
<li><code>flags</code>：可选参数，用于控制正则表达式的匹配方式。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>返回替换后的字符串。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line">  </span><br><span class="line">pattern = <span class="string">&#x27;world&#x27;</span>  </span><br><span class="line">repl = <span class="string">&#x27;Python&#x27;</span>  </span><br><span class="line">string = <span class="string">&#x27;Hello, world! This is a test.&#x27;</span>  </span><br><span class="line">new_string = re.sub(pattern, repl, string)  </span><br><span class="line"><span class="built_in">print</span>(new_string)  <span class="comment"># 输出: Hello, Python! This is a test.</span></span><br></pre></td></tr></table></figure>

<p>这四个函数是Python中处理正则表达式时最常用的工具，它们各自有不同的用途和行为，但共同构成了强大的文本处理能力。</p>
<h4 id="2-3多线程处理"><a href="#2-3多线程处理" class="headerlink" title="2.3多线程处理"></a>2.3多线程处理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def process_datas(datas,MODEL_NAME):</span><br><span class="line">    results = []</span><br><span class="line">    # 定义线程池 选择16线程</span><br><span class="line">    with ThreadPoolExecutor(max_workers=16) as executor:</span><br><span class="line">        # 这里我们使用future_data 存储每个线程的数据</span><br><span class="line">        future_data = &#123;&#125;</span><br><span class="line">        # 这里的lens记录了调用api的次数，也就是我们每个问题背景下的所有子问题之和。</span><br><span class="line">        lens = 0</span><br><span class="line">        # 送入多线程任务</span><br><span class="line">        # 这里每个data下是一个问题背景，其中包含多个子问题。</span><br><span class="line">        for data in tqdm(datas, desc=&quot;Submitting tasks&quot;, total=len(datas)):</span><br><span class="line">            problem = data[&#x27;problem&#x27;]</span><br><span class="line">            # 这里面我们用enumerate方法每次循环得到问题的序号id和实际的问题。</span><br><span class="line">            for id,question in enumerate(data[&#x27;questions&#x27;]):</span><br><span class="line">                prompt = get_prompt(problem, </span><br><span class="line">                                    question[&#x27;question&#x27;], </span><br><span class="line">                                    question[&#x27;options&#x27;],</span><br><span class="line">                                    )</span><br><span class="line">                # 这里送入线程池等待处理，使用api_retry，向api_retry传入MODEL_NAME, prompt参数</span><br><span class="line">                future = executor.submit(api_retry, MODEL_NAME, prompt)</span><br><span class="line">                # 每个线程我们存储对应的json问题数据以及问题序号id，这样我们就能定位出执行的是哪个子问题</span><br><span class="line">                future_data[future] = (data,id)</span><br><span class="line">                time.sleep(0.6)  # 控制每0.6秒提交一个任务 防止接口超过并发数</span><br><span class="line">                lens += 1</span><br><span class="line">        # 处理多线程任务</span><br><span class="line">        for future in tqdm(as_completed(future_data), total=lens, desc=&quot;Processing tasks&quot;):</span><br><span class="line">            # print(&#x27;data&#x27;,data)</span><br><span class="line">            # 取出每个线程中的字典数据及对应的问题id</span><br><span class="line">            data = future_data[future][0]</span><br><span class="line">            problem_id = future_data[future][1]</span><br><span class="line">            try:</span><br><span class="line">                # 获取api运行结果</span><br><span class="line">                res  = future.result()</span><br><span class="line">                # 抽取大语言模型返回结果</span><br><span class="line">                extract_response = extract(res)</span><br><span class="line">                # print(&#x27;res&#x27;,extract_response)</span><br><span class="line">                # 装入answer字段</span><br><span class="line">                data[&#x27;questions&#x27;][problem_id][&#x27;answer&#x27;] = extract_response</span><br><span class="line">                # 在结果列表中新增数据字典</span><br><span class="line">                results.append(data)</span><br><span class="line">                # print(&#x27;data&#x27;,data)</span><br><span class="line">                </span><br><span class="line">            except Exception as e:</span><br><span class="line">                logger.error(f&quot;Failed to process text: &#123;data&#125;. Error: &#123;e&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    return results</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AI大模型</category>
      </categories>
      <tags>
        <tag>baseline</tag>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>AI大模型-3Baseline优化加速</title>
    <url>/posts/47240e3d/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Andrew ng——机器学习通识及代价函数</title>
    <url>/posts/b2e49bf5/</url>
    <content><![CDATA[<h1 id="吴恩达机器学习1"><a href="#吴恩达机器学习1" class="headerlink" title="吴恩达机器学习1"></a>吴恩达机器学习1</h1><h2 id="1-1-什么是机器学习"><a href="#1-1-什么是机器学习" class="headerlink" title="1.1 什么是机器学习"></a>1.1 什么是机器学习</h2><p>​	1.Field of study that gives computers the ability to learn without being explicitly programmed. (Arthur Samuel)<br>​	2.A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E. (Tom Mitchell)<br>无论哪种定义，通俗地讲就是计算机通过经验学习进行性能优化</p>
<h2 id="1-2监督学习"><a href="#1-2监督学习" class="headerlink" title="1.2监督学习"></a>1.2监督学习</h2><p><strong>监督学习</strong>即给算法一个有标签集且包含正确答案的数据集，也就是说我们知道output、input以及二者之间的关系，我们期望找到二者之间的映射关系，从而对一个新的数据作出预测分析。可分为两类：</p>
<p><strong>1.回归问题：</strong>即连续问题，通过线性拟合来分析数据</p>
<p><strong>2.分类问题：</strong>即离散问题，通过某一标准来划分数据</p>
<h2 id="1-3无监督学习"><a href="#1-3无监督学习" class="headerlink" title="1.3无监督学习"></a>1.3无监督学习</h2><p><strong>无监督学习</strong>即给算法一个无标签集的数据集，让其自行处理分析。</p>
<p><strong>聚类算法：</strong>将无标签的数据集分为不同的簇，是无监督学习的一种算法。</p>
<h2 id="2-1模型表示"><a href="#2-1模型表示" class="headerlink" title="2.1模型表示"></a>2.1模型表示</h2><h3 id="2-1-1线性回归"><a href="#2-1-1线性回归" class="headerlink" title="2.1.1线性回归"></a>2.1.1线性回归</h3><p>​		这是房价预测的例子， 训练集如下：</p>
<p><img src="/posts/b2e49bf5/542362-20181026195932622-1764193274.png" alt="训练集"></p>
<p>定义各个变量的含义如下：</p>
<p>m 　　　  代表训练集中实例的数量<br>x 　　　　代表特征&#x2F;输入变量<br>y 　　　　代表目标变量&#x2F;输出变量<br>(x,y) 　　   代表训练集中的实例<br>(x(i),y(i))     代表第 i 个观察实例：其中x(i) 代表第i个输入变量, y(i)代表第i个目标变量<br>h 　　　　代表学习算法的解决方案或函数，也称为假设（hypothesis）</p>
<h3 id="2-1-2单变量线性回归"><a href="#2-1-2单变量线性回归" class="headerlink" title="2.1.2单变量线性回归"></a>2.1.2单变量线性回归</h3><p>h 根据输入的 x 值来得出 y 值， y 值对应房子的价。因此， h 是一个从x 到 y 的函数映射。</p>
<p><strong>单变量线性回归问题：</strong>只含有一个特征&#x2F;输入变量</p>
<p><img src="/posts/b2e49bf5/542362-20181026195816561-1002060993.png" alt="单变量线性回归机理"></p>
<h2 id="2-2代价函数"><a href="#2-2代价函数" class="headerlink" title="2.2代价函数"></a>2.2代价函数</h2><p>​		线性回归算法优化的目标是：选取最有可能与数据相拟合的直线。数据与直线的误差，称为<strong>建模误差 modeling error</strong>。为了使建模误差最小，我们需要调整参数θ0 和 θ1，使得<strong>代价函数Cost function</strong> J(θ0, θ1)的值最小。</p>
<h3 id="2-2-1单变量线性回归（Linear-regression-with-one-variable）"><a href="#2-2-1单变量线性回归（Linear-regression-with-one-variable）" class="headerlink" title="2.2.1单变量线性回归（Linear regression with one variable）"></a>2.2.1单变量线性回归（Linear regression with one variable）</h3><p><strong>假设函数Hypothesis Function：</strong></p>
<img src="/posts/b2e49bf5/542362-20181026211231703-155247107.png" alt="假设函数" style="zoom: 50%;">

<p><strong>代价函数 Cost Function</strong>（<strong>平方误差代价函数 Squared error cost function</strong>）</p>
<img src="/posts/b2e49bf5/542362-20181026203723114-307876824.png" alt="代价函数" style="zoom: 67%;">

<p>​		</p>
<p>**优化目标 **  <strong>goal</strong></p>
<p><img src="/posts/b2e49bf5/image-20240807103251677.png" alt="优化目标"></p>
<h3 id="2-2-2多元线性回归（-Multivariate-Linear-Regression）"><a href="#2-2-2多元线性回归（-Multivariate-Linear-Regression）" class="headerlink" title="2.2.2多元线性回归（ Multivariate Linear Regression）"></a>2.2.2<strong>多元线性回归</strong>（ Multivariate Linear Regression）</h3><p>假设函数：</p>
<img src="/posts/b2e49bf5/image-20240807103529358.png" alt="假设函数" style="zoom:80%;">

<p>代价函数：</p>
<img src="/posts/b2e49bf5/image-20240807103900151.png" alt="代价函数" style="zoom:80%;">

<p><strong>优化目标</strong>：</p>
<img src="/posts/b2e49bf5/image-20240807103934902.png" alt="优化目标" style="zoom:80%;">

<h2 id="2-3代价函数的直观理解Ⅰ"><a href="#2-3代价函数的直观理解Ⅰ" class="headerlink" title="2.3代价函数的直观理解Ⅰ"></a>2.3代价函数的直观理解Ⅰ</h2><p>取将 θ0 固定为 0时，代价函数简化为只关于 θ1 的函数：</p>
<img src="/posts/b2e49bf5/542362-20181027063556775-1380986435.png" alt="θ0=0" style="zoom:80%;">

<p>下面的例子里，三个数据点的坐标是（1,1）（2,2）（3,3）。当将 θ0固定为0，只变化 θ1时， 代价函数是一条二次曲线。</p>
<p>　　当 θ1 分别取值1，0.5，0的时候，对应左边从上到下三条曲线。</p>
<p>　　当 θ1 取1时，J(θ1) &#x3D; 0 , 此时 J(θ1) 最小，处于曲线最低点，是我们想要的结果。</p>
<img src="/posts/b2e49bf5/542362-20181027063243260-431488824.png" alt="代价函数图像" style="zoom:80%;">

<h2 id="2-4代价函数的直观理解Ⅱ"><a href="#2-4代价函数的直观理解Ⅱ" class="headerlink" title="2.4代价函数的直观理解Ⅱ"></a>2.4代价函数的直观理解Ⅱ</h2><p> 当 θ0 和 θ1 都发生变化时，代价函数 J(θ0 , θ1) 在三维空间中图形如下：</p>
<img src="/posts/b2e49bf5/542362-20181027065558275-1393263845.png" alt="θ0与θ1均不固定" style="zoom:80%;">

<p>​	因为三维图像看起来太复杂， 将它投射到二维平面。引入<strong>等高线contour plot</strong> 的概念，也叫contour figure。等高线上的点，对应的代价函数 J(θ0 , θ1) 取值相同。</p>
<p> 　 下面两个图，右边红点对应的直线如左图，可以看出拟合的都不好。</p>
<img src="/posts/b2e49bf5/542362-20181027065713598-2141464287.png" alt="拟合1" style="zoom: 50%;">

<img src="/posts/b2e49bf5/542362-20181027065723938-1342446833.png" alt="拟合2" style="zoom: 50%;">

<p>​	下图取值位于三维图形的最低点，在二维图形上位于等高线的中心。对应的假设函数 h(x) 直线如左图。虽然拟合数据有一些误差（蓝色竖线），但是已经很接近最小值了。</p>
<img src="/posts/b2e49bf5/542362-20181027065851220-2060487712.png" alt="拟合3" style="zoom:67%;">



<p>以上为机器学习通识及代价函数相关知识，下一节更新内容为代价函数优化算法。</p>
]]></content>
      <tags>
        <tag>吴恩达 -机器学习 -代价函数 -线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>My first blog !</title>
    <url>/posts/c86c5a61/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在本篇文章里我将简单介绍我的个人博客搭建过程</p>
]]></content>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
        <tag>node.js</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0/</url>
    <content><![CDATA[<h1 id="TIM（Timer）定时器"><a href="#TIM（Timer）定时器" class="headerlink" title="TIM（Timer）定时器"></a>TIM（Timer）定时器</h1><p><img src="https://img-blog.csdnimg.cn/e6c242361263453ba8691f1292842f03.png" alt="在这里插入图片描述"></p>
<p>为什么在72MHz计数时钟下可以实现最大59.65s的定时?<br>72M&#x2F;65536&#x2F;65536，得到的是中断频率，然后取倒数，就是59.65秒多，大家可以自己算一下。<br>详细解释：在定时器中,预分频器和计数器都是16位的,所以它们的最大值是65535,而不是65536。</p>
<p>预分频器的最大值决定了计数时钟的频率,而计数器的最大值决定了定时器的最大计数周期。因此,如果预分频器和计数器的最大值都设置为65535,那么定时器的最大时间就是72MHz&#x2F;65536&#x2F;65536，得到的是中断频率，倒数就是中断时间。【最大值是65536，但计数是从0~65535】<br><img src="https://img-blog.csdnimg.cn/0c44cedb211b40ef85e0be30d0e321c0.png" alt="定时器类型"></p>
<h2 id="1-1-基本定时器（TIM6和TIM7）"><a href="#1-1-基本定时器（TIM6和TIM7）" class="headerlink" title="1.1 基本定时器（TIM6和TIM7）"></a>1.1 基本定时器（TIM6和TIM7）</h2><p><img src="https://img-blog.csdnimg.cn/4d5def101ec94a80b471cbe15a858aaf.png" alt="基本定时器"></p>
<h3 id="1-1-1-时基单元"><a href="#1-1-1-时基单元" class="headerlink" title="1.1_1_ 时基单元"></a>1.1_1_ 时基单元</h3><p><img src="https://img-blog.csdnimg.cn/d992b082b9cb400f94fc7760e84d1d68.png" alt="在这里插入图片描述"></p>
<p>这个可编程定时器的主要部分是一个带有自动重装载的16位累加计数器,计数器的时钟通过一个预分频器得到。<br>软件可以读写计数器、自动重装载寄存器和预分频寄存器,即使计数器运行时也可以操作。时基单元包含：</p>
<ul>
<li><p>预分频寄存器(TIMx_PSC)</p>
<p>预分频器</p>
<p>预分频可以以系数介于1至65536之间的任意数值对计数器时钟分频,就是对输入的基淮频率提前进行一个分频的操作。它是通过一个16位寄存器(TIMx-PSC)的计数实现分频。因为TIMx-PSC控制寄存器具有缓冲,可以在运行过程中改变它的数值,新的预分频数值将在下一个更新事件时起作用。</p>
<p><strong>假设这个寄存器写0，就是不分频，或者说是1分频，这时候输出频率&#x3D;输入频率&#x3D;72MHz；如果预分频器写1，那就是2分频，输出频率&#x3D;输入频率&#x2F;2&#x3D;36MHz,所以预分频器的值和实际的分频系数相差了1，即实际分频系数&#x3D;预分频器的值+1。</strong></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/1ca319768b75449c88f39d92f7df8713.png" alt="在这里插入图片描述"></p>
<p>注意：实际的设置计数器使能信号CNT_EN相对于CEN滞后一个时钟周期。</p>
<ul>
<li><p>计数器寄存器(TIMx_CNT)</p>
<p>计数器由预分频输出CK_CNT驱动，设置TIMx_CR1寄存器中的计数器使能位(CEN)使能计数器计数。这个计数器可以对预分频后的计数时钟进行计数,计数时钟每来一个上升滑，计数器的值就加1,由于这个计数器也是16位的，所以里面的值可以从0一直加到65535，如果再加的话，计数器就会回到0重新开始。所以计数器的值在计时过程中会不断地自增运行，当自增运行到目标值时，产生中断，那就完成了定时的任务，所以现在还需要一个存储目标值的寄存器，那就是自动重装寄存器了。</p>
</li>
</ul>
<p><strong>时序图讲解</strong></p>
<p>自动重裝载寄存器(TIMx_ARR)<br>自动重装载寄存器是预加载的,每次读写自动重装载寄存器时,实际上是通过读写预加载寄存器实现。根据TIMx CR1寄存器中的自动重装载预加载使能位(ARPE),写入预加载寄存器的内容能够立即或在每次更新事件时,传送到它的影子寄存器。当TIMx CR1寄存器的UDIS位为’0’,则每当计数器达到溢出值时,硬件发出更新事件;软件也可以产生更新事件;关于更新事件的产生，随后会有详细的介绍。</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
